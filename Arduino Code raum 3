// Arduino Nano / Uno - PIR -> gesteuerte Relais (Pins 2..5)
// Verhalten:
// - PIR (Pin 10) HIGH -> Event startet für EVENT_DURATION_MS
// - Relay 0 (Pin 2) und Relay 1 (Pin 3) bleiben dauerhaft AN während des Events.
// - Die anderen Relais (ab Index 2) pulsen: ON für RELAY_PULSE_MS, dann OFF, mit Intervall RELAY_INTERVAL_MS[].
// - Nach Event-Ende (EVENT_DURATION_MS) wird alles ausgeschaltet und es wartet auf neues PIR HIGH.

const uint8_t RELAY_PINS[] = {2, 3, 4, 5};
const uint8_t NUM_RELAYS = sizeof(RELAY_PINS) / sizeof(RELAY_PINS[0]);

const uint8_t PIR_PIN = 10;
const uint8_t LED_BUILTIN_PIN = LED_BUILTIN; // Status-LED während Event

// === EINSTELLUNGEN ===
unsigned long EVENT_DURATION_MS = 600000UL;  // z.B. 20s
const unsigned long RELAY_PULSE_MS = 500UL; // 500 ms ON

// Anfangsverzögerung für jedes Relay (ms)
unsigned long RELAY_INITIAL_DELAY_MS[NUM_RELAYS] = {6000UL, 1000UL, 3000UL, 5000UL};

// Intervall für pulsende Relais (ms)
unsigned long RELAY_INTERVAL_MS[NUM_RELAYS] = {21000UL, 0UL, 0UL, 32000UL};
// ======================

// Wenn dein Relais-Modul aktiv LOW ist:
const uint8_t RELAY_ON  = LOW;
const uint8_t RELAY_OFF = HIGH;

// Laufzeitvariablen
bool eventRunning = false;
unsigned long eventStart = 0;
unsigned long nextRelayTriggerTime[NUM_RELAYS];
bool relayIsOn[NUM_RELAYS];
unsigned long relayOnSince[NUM_RELAYS];
int lastPirState = LOW;

unsigned long nowMillis() { return millis(); }

void setup() {
  Serial.begin(115200);
  for (uint8_t i = 0; i < NUM_RELAYS; ++i) {
    pinMode(RELAY_PINS[i], OUTPUT);
    digitalWrite(RELAY_PINS[i], RELAY_OFF);
    relayIsOn[i] = false;
    relayOnSince[i] = 0;
    nextRelayTriggerTime[i] = 0;
  }

  pinMode(PIR_PIN, INPUT);
  pinMode(LED_BUILTIN_PIN, OUTPUT);
  digitalWrite(LED_BUILTIN_PIN, LOW);

  Serial.println("Setup fertig");
}

void loop() {
  unsigned long t = nowMillis();
  int pir = digitalRead(PIR_PIN);

  if (!eventRunning && pir == HIGH && lastPirState == LOW) {
    startEvent(t);
  }

  if (eventRunning) {
    unsigned long elapsed = t - eventStart;

    for (uint8_t i = 0; i < NUM_RELAYS; ++i) {
      handleRelay(i, t);
    }

    if (elapsed >= EVENT_DURATION_MS) {
      stopEvent();
    }
  }

  lastPirState = pir;
  delay(10);
}

void startEvent(unsigned long t) {
  eventRunning = true;
  eventStart = t;
  digitalWrite(LED_BUILTIN_PIN, HIGH);
  Serial.print("Event gestartet um ");
  Serial.println(t);

  for (uint8_t i = 0; i < NUM_RELAYS; ++i) {
    nextRelayTriggerTime[i] = eventStart + RELAY_INITIAL_DELAY_MS[i];
    relayIsOn[i] = false;
    relayOnSince[i] = 0;
    Serial.print("Relay ");
    Serial.print(i);
    Serial.print(" nextTrigger @ +");
    Serial.print(RELAY_INITIAL_DELAY_MS[i]);
    Serial.println(" ms");
  }
}

void stopEvent() {
  eventRunning = false;
  Serial.print("Event gestoppt um ");
  Serial.println(nowMillis());
  for (uint8_t i = 0; i < NUM_RELAYS; ++i) {
    digitalWrite(RELAY_PINS[i], RELAY_OFF);
    relayIsOn[i] = false;
    relayOnSince[i] = 0;
    nextRelayTriggerTime[i] = 0;
  }
  digitalWrite(LED_BUILTIN_PIN, LOW);
}

void handleRelay(uint8_t i, unsigned long t) {
  // Die ersten beiden Relais (Index 0 & 1) sind dauerhaft AN während des Events
  if (i == 2 || i == 1) {
    if (!relayIsOn[i] && (long)(t - nextRelayTriggerTime[i]) >= 0) {
      digitalWrite(RELAY_PINS[i], RELAY_ON);
      relayIsOn[i] = true;
      relayOnSince[i] = t;
      Serial.print("Relay (dauerhaft) ");
      Serial.print(RELAY_PINS[i]);
      Serial.println(" ON");
    }
    return;
  }

  // Alle anderen Relais: pulsierend
  if (nextRelayTriggerTime[i] == 0)
    nextRelayTriggerTime[i] = eventStart + RELAY_INITIAL_DELAY_MS[i];

  if (!relayIsOn[i]) {
    if ((long)(t - nextRelayTriggerTime[i]) >= 0) {
      digitalWrite(RELAY_PINS[i], RELAY_ON);
      relayIsOn[i] = true;
      relayOnSince[i] = t;

      unsigned long interval = RELAY_INTERVAL_MS[i];
      if (interval == 0) interval = 5000UL;
      nextRelayTriggerTime[i] = nextRelayTriggerTime[i] + interval;

      Serial.print("Relay (pulse) ");
      Serial.print(RELAY_PINS[i]);
      Serial.println(" ON (pulse start)");
    }
  } else {
    if (t - relayOnSince[i] >= RELAY_PULSE_MS) {
      digitalWrite(RELAY_PINS[i], RELAY_OFF);
      relayIsOn[i] = false;
      relayOnSince[i] = 0;
      Serial.print("Relay (pulse) ");
      Serial.print(RELAY_PINS[i]);
      Serial.println(" OFF (pulse end)");
    }
  }
}
